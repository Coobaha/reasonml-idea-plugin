{
  parserClass="com.reason.parser.ReasonMLParser"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="ReasonML"
  psiImplClassSuffix="Impl"
  psiPackage="com.reason.psi"
  psiImplPackage="com.reason.psi.impl"

  elementTypeHolderClass="com.reason.psi.ReasonMLTypes"
  elementTypeClass="com.reason.psi.ReasonMLElementType"
  tokenTypeClass="com.reason.psi.ReasonMLTokenType"

  psiImplUtilClass="com.reason.psi.impl.ReasonMLPsiImplUtil"
}

reasonFile ::=
    ( COMMENT | open_statement | module_statement | include_statement | let_statement | expr_statement | type_statement | external_statement )*

// ----------
// MODULE
// ----------

open_statement ::=
    OPEN module_path SEMI

module_statement ::=
    MODULE module_name EQUAL LBRACE module_body RBRACE SEMI { methods=[getPresentation] }

module_body ::=
    (  module_statement
    | include_statement
    | type_statement
    | let_statement )*

module_expr ::=  // https://caml.inria.fr/pub/docs/manual-ocaml/modules.html#module-expr
      module_path

include_statement ::=
    INCLUDE module_expr (module_expr)* SEMI

// ----------
// TYPE
//   https://caml.inria.fr/pub/docs/manual-ocaml/types.html#typexpr
// ----------

type_statement ::=
     TYPE type_constr_name (EQUAL type_information)? SEMI {
        methods=[getPresentation]
    }

type_information ::=
    type_constr? (tuple_type_decl | record_type_decl)

// https://caml.inria.fr/pub/docs/manual-ocaml/types.html#typexpr
type_expr ::=
      LPAREN type_expr (COMMA type_expr)* RPAREN type_constr
    | type_constr (type_expr | (ARROW type_expr)*)

// https://caml.inria.fr/pub/docs/manual-ocaml/names.html#typeconstr
type_constr ::=
      bs_directive
    | (module_path DOT)? type_constr_name

poly_type_expr ::= /*?*/
      (QUOTE LIDENT)+ DOT type_expr
    | OPTION type_constr
    | type_expr

// ----------
// external
//   https://caml.inria.fr/pub/docs/manual-ocaml/modules.html
// ----------

external_statement ::=
    EXTERNAL value_name COLON type_information external_declaration SEMI { methods=[getPresentation] }

external_declaration ::=
      EQUAL external_alias
    | ARROW value_name EQUAL external_alias bs_directive*

external_alias ::=
    STRING

// ----------
// expr
//   https://caml.inria.fr/pub/docs/manual-ocaml/expr.html
// ----------

expr_statement ::=
    expr+ SEMI

expr ::=
      NONE
    | SOME expr
    | FUN fun_decl
    | LPAREN expr RPAREN
    | LBRACE (DOT DOT DOT value_name COMMA?)? expr RBRACE
    | jsx
    | let_binding
    | value_expr (
              LPAREN expr RPAREN
            | QUESTION_MARK expr
            | PLUS expr
            | PLUSDOT expr
            | MINUS expr
            | MINUSDOT expr
            | SLASH expr
            | SLASHDOT expr
            | STAR expr
            | STARDOT expr
            | LT expr
            | GT expr
            | CARRET expr
            | COMMA expr
            | COLON expr
            | expr )*

value_expr ::=
      constant
    | value_path (DOT value_path)* (SHARP SHARP value_name | argument*)

argument ::=
      constant
    | value_name (SHARP SHARP value_name | DOT field)?
    | jsx
    | record_decl

// ----------
// JSX
// ----------

jsx ::=
    start_tag tag_property* ( AUTO_CLOSE_TAG | GT jsxContent* end_tag )

start_tag ::=
    LT tag_name

end_tag ::=
    CLOSE_TAG tag_name GT

tag_property ::=
    value_name EQUAL (LPAREN expr RPAREN | record_decl | constant | value_name)

jsxContent ::=
      COMMENT
    | LPAREN expr RPAREN
    | jsx

// ----------
// LET
// ----------

let_statement ::=
    let_binding SEMI {
        //pin=1 recoverWhile=recover_statement
        methods=[getPresentation]
    }

let_binding ::=
    LET value_name let_binding_body

let_binding_body ::=
      EQUAL ( expr | LBRACE expr (SEMI expr)* RBRACE )
    | fun_decl

fun_decl ::=
    (parameter)* ARROW (
          LBRACE expr (SEMI expr)* RBRACE
        | expr
    )

// https://caml.inria.fr/pub/docs/manual-ocaml/patterns.html#pattern
parameter ::=
      pattern_expr
    | SHORTCUT value_name (EQUAL (constant | QUESTION_MARK))?
    | LPAREN pattern_expr (DOT type_expr)? RPAREN
    | LBRACE field (COMMA field)* RBRACE

pattern_expr ::=
      constant
    | value_name

// https://caml.inria.fr/pub/docs/manual-ocaml/names.html#field
field ::=
    (module_path DOT)? field_name

// ----------
// RECORD / tuple
// ----------

record_type_decl ::=
      LBRACE DOT DOT RBRACE
    | LBRACE (DOT|DOT DOT)? field_type_decl (COMMA field_type_decl)* RBRACE

field_type_decl ::=
    field_name COLON poly_type_expr

tuple_type_decl ::=
    LPAREN tuple_type_field_decl (COMMA tuple_type_field_decl)* RPAREN

tuple_type_field_decl ::=
    poly_type_expr

record_decl ::=
    LBRACE field_decl (COMMA field_decl)* RBRACE

field_decl ::=
      DOT DOT DOT field_name
    | field_name COLON expr

// ----------
// CONSTANTS
//   https://caml.inria.fr/pub/docs/manual-ocaml/const.html#constant
// ----------

constant ::=
      INT
    | FLOAT
    | STRING
    | FALSE
    | TRUE
    | UNIT
    | LBRACKET RBRACKET
    | LPAREN RPAREN

// ----------
// REFERRING NAMEDÂ OBJECTS
//   https://caml.inria.fr/pub/docs/manual-ocaml/names.html#sec90
// ----------

value_path ::=
      value_name
    | module_path DOT value_name

module_path ::=
    module_name (DOT module_name)*

// ----------
// NAMES
// https://caml.inria.fr/pub/docs/manual-ocaml/names.html
// ----------

value_name ::=
    LIDENT

tag_name ::=
    LIDENT | UIDENT

field_name ::=
    STRING | LIDENT

module_name ::=
    UIDENT

type_constr_name ::=
    LIDENT

// ----------
// BUCKLESCRIPT
// ----------

bs_directive ::=
    LBRACKET (BBS|BS) DOT (value_name|MODULE) constant? RBRACKET