{
  parserClass="com.reason.parser.ReasonMLParser"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="ReasonML"
  psiImplClassSuffix="Impl"
  psiPackage="com.reason.psi"
  psiImplPackage="com.reason.psi.impl"

  elementTypeHolderClass="com.reason.psi.ReasonMLTypes"
  elementTypeClass="com.reason.psi.ReasonMLElementType"
  tokenTypeClass="com.reason.psi.ReasonMLTokenType"

  psiImplUtilClass="com.reason.psi.impl.ReasonMLPsiImplUtil"
}

reasonFile ::=
    ( COMMENT | open_statement | module_statement | include_statement | let_statement | expr_statement | type_statement | external_statement )*

// ----------
// MODULE
// ----------

open_statement ::=
    OPEN module_path SEMI

module_statement ::=
    MODULE module_name EQUAL LBRACE module_body RBRACE SEMI { methods=[getPresentation] }

module_body ::=
    (  module_statement
    | include_statement
    | type_statement
    | let_statement )*

private module_expr ::=  // https://caml.inria.fr/pub/docs/manual-ocaml/modules.html#module-expr
      module_path

include_statement ::=
    INCLUDE module_expr (module_expr)* SEMI

// ----------
// TYPE
//   https://caml.inria.fr/pub/docs/manual-ocaml/types.html#typexpr
// ----------

type_statement ::=
     TYPE type_constr_name (EQUAL type_information)? SEMI {
        methods=[getPresentation]
    }

private type_information ::=
      UNIT
    | type_constr? (tuple_type_decl | record_type_decl)

// https://caml.inria.fr/pub/docs/manual-ocaml/types.html#typexpr
type_expr ::=
      UNIT
    | LPAREN type_expr (COMMA type_expr)* RPAREN type_constr
    | type_constr (type_expr | (ARROW type_expr)*)

// https://caml.inria.fr/pub/docs/manual-ocaml/names.html#typeconstr
type_constr ::=
      bs_directive
    | (module_path DOT)? type_constr_name

poly_type_expr ::= /*?*/
      (QUOTE LIDENT)+ DOT type_expr
    | OPTION type_constr
    | type_expr

// ----------
// external
//   https://caml.inria.fr/pub/docs/manual-ocaml/modules.html
// ----------

external_statement ::=
    EXTERNAL value_name COLON type_information external_declaration SEMI { methods=[getPresentation] }

external_declaration ::=
      EQUAL external_alias
    | ARROW value_name EQUAL external_alias bs_directive*

external_alias ::=
    STRING

// ----------
// expr
//   https://caml.inria.fr/pub/docs/manual-ocaml/expr.html
// ----------

expr_statement ::=
    sequenced_expr SEMI

private sequenced_expr ::=
    expr (SEMI expr)*

expr ::=
      NONE
    | SOME expr
    | FUN parameter* ARROW let_binding_body
    | LPAREN sequenced_expr? RPAREN
    | LBRACE (DOT DOT DOT value_name COMMA?)? expr RBRACE
    | IF LPAREN boolean_expr RPAREN LBRACE sequenced_expr RBRACE (ELSE LBRACE sequenced_expr RBRACE)*
    | pattern_matching
    | jsx
    | let_binding
    | value_expr (
              LPAREN expr RPAREN
            | QUESTION_MARK expr
            | PLUS expr
            | PLUSDOT expr
            | MINUS expr
            | MINUSDOT expr
            | MUL expr
            | MULDOT expr
            | SLASH expr
            | SLASHDOT expr
            | STAR expr
            | STARDOT expr
            | LT expr
            | GT expr
            | CARRET expr
            | COMMA expr
            | COLON expr
            | expr )*

boolean_expr ::=
    expr EQEQEQUAL expr

value_expr ::=
      signed_constant
    | value_path (DOT value_path)* (SHARP SHARP value_name | argument*)

argument ::=
      constant
    | value_name (SHARP SHARP value_name | DOT field)?
    | jsx
    | record_decl

// ----------
// PATTERN
//    https://caml.inria.fr/pub/docs/manual-ocaml/expr.html#pattern-matching
// ----------

pattern_matching ::=
    PIPE pattern ARROW expr (PIPE pattern ARROW expr)*

pattern ::=
      NONE
    | SOME value_name
    | value_name
    | constant

// ----------
// JSX
// ----------

jsx ::=
    start_tag tag_property* ( AUTO_CLOSE_TAG | GT jsxContent* end_tag )

start_tag ::=
    LT tag_name

end_tag ::=
    CLOSE_TAG tag_name GT

tag_property ::=
    value_name EQUAL (LPAREN expr RPAREN | record_decl | constant | value_name)

jsxContent ::=
      COMMENT
    | LPAREN expr RPAREN
    | jsx

// ----------
// LET
// ----------

let_statement ::=
    let_binding SEMI {
        methods=[getPresentation]
    }

let_binding ::=
    LET value_name parameter* (
          EQUAL let_binding_body
        | ARROW let_binding_body/*scoped_expr*/
    )

private let_binding_body ::=
      LBRACE expr (SEMI expr)* RBRACE
    | expr

// https://caml.inria.fr/pub/docs/manual-ocaml/patterns.html#pattern
parameter ::=
      parameter_expr
    | SHORTCUT value_name (EQUAL (constant | QUESTION_MARK))?
    | LPAREN parameter_expr (DOT type_expr)? RPAREN
    | LBRACE field (COMMA field)* RBRACE

parameter_expr ::=
      constant
    | value_name

// https://caml.inria.fr/pub/docs/manual-ocaml/names.html#field
field ::=
    (module_path DOT)? field_name

// ----------
// RECORD / tuple
// ----------

record_type_decl ::=
      LBRACE DOT DOT RBRACE
    | LBRACE (DOT|DOT DOT)? field_type_decl (COMMA field_type_decl)* RBRACE

field_type_decl ::=
    field_name COLON poly_type_expr

tuple_type_decl ::=
    LPAREN tuple_type_field_decl (COMMA tuple_type_field_decl)* RPAREN

tuple_type_field_decl ::=
    poly_type_expr

record_decl ::=
    LBRACE field_decl (COMMA field_decl)* RBRACE

field_decl ::=
      DOT DOT DOT field_name
    | field_name COLON expr

// ----------
// CONSTANTS
//   https://caml.inria.fr/pub/docs/manual-ocaml/const.html#constant
// ----------

constant ::=
      INT
    | FLOAT
    | STRING
    | FALSE
    | TRUE
    | UNIT
    | LBRACKET RBRACKET
    | LPAREN RPAREN

signed_constant ::=
    constant
  | MINUS INT
  | MINUS FLOAT
  | PLUS INT
  | PLUS FLOAT

// ----------
// REFERRING NAMEDÂ OBJECTS
//   https://caml.inria.fr/pub/docs/manual-ocaml/names.html#sec90
// ----------

value_path ::=
      value_name
    | module_path DOT value_name

module_path ::=
    module_name (DOT module_name)*

// ----------
// NAMES
// https://caml.inria.fr/pub/docs/manual-ocaml/names.html
// ----------

value_name ::=
    LIDENT

tag_name ::=
    LIDENT | UIDENT

field_name ::=
    STRING | LIDENT

module_name ::=
    UIDENT

type_constr_name ::=
    LIDENT

// ----------
// BUCKLESCRIPT
// ----------

bs_directive ::=
    LBRACKET (BBS|BS) DOT (value_name|MODULE) constant? RBRACKET