{
  parserClass="com.reason.parser.ReasonMLParser"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="ReasonML"
  psiImplClassSuffix="Impl"
  psiPackage="com.reason.psi"
  psiImplPackage="com.reason.psi.impl"

  elementTypeHolderClass="com.reason.psi.ReasonMLTypes"
  elementTypeClass="com.reason.psi.ReasonMLElementType"
  tokenTypeClass="com.reason.psi.ReasonMLTokenType"

  psiImplUtilClass="com.reason.psi.impl.ReasonMLPsiImplUtil"
}

reasonFile ::=
    ( COMMENT | module_statement | include_statement | let_binding | expr_statement | type_statement | external_statement )*

// ----------
// MODULE
// ----------

module_statement ::=
    MODULE module_name EQUAL LBRACE module_body RBRACE SEMI { methods=[getPresentation] }

module_body ::=
    (  module_statement
    | include_statement
    | type_statement
    | let_binding )*

module_expr ::=  // https://caml.inria.fr/pub/docs/manual-ocaml/modules.html#module-expr
      module_path

include_statement ::=
    INCLUDE module_expr (module_expr)* SEMI

// ----------
// TYPE
// ----------

type_statement ::=
      TYPE type_expr type_definition? SEMI {
//        pin=1 recoverWhile=recover_statement
        methods=[getPresentation]
    }

// https://caml.inria.fr/pub/docs/manual-ocaml/types.html#typexpr
type_expr ::=
    type_constr (ARROW type_constr)*

// https://caml.inria.fr/pub/docs/manual-ocaml/names.html#typeconstr
type_constr ::=
    (module_path DOT)? type_constr_name

// https://caml.inria.fr/pub/docs/manual-ocaml/names.html#typeconstr-name
type_constr_name ::=
    LIDENT

type_definition ::=
    EQUAL LBRACE record_body RBRACE

// ----------
// external
// ----------

external_statement ::=
    EXTERNAL value_name COLON type_expr EQUAL external_alias? bs_directive* SEMI { methods=[getPresentation] }

external_alias ::=
    STRING

// ----------
// expr
//   https://caml.inria.fr/pub/docs/manual-ocaml/expr.html
// ----------

expr_statement ::=
    expr+ SEMI

expr ::=
      constant
    | NONE
    | SOME expr
    | value_path argument+
    | jsx
    | LBRACE record_body RBRACE
    | LPAREN expr RPAREN
    | expr PLUS expr

argument ::=
      constant
    | value_name (DOT field)?
    | jsx
    | LBRACE record_field RBRACE
    | SHORTCUT value_name

// ----------
// JSX
// ----------

jsx ::=
    start_tag tag_property* ( AUTO_CLOSE_TAG | GT jsxContent* end_tag )

start_tag ::=
    LT tag_name

end_tag ::=
    CLOSE_TAG tag_name GT

tag_property ::=
    value_name EQUAL (LPAREN expr RPAREN | constant)

jsxContent ::=
    LPAREN expr RPAREN

// ----------
// LET
// ----------

let_binding ::=
    LET value_name let_binding_body SEMI {
//        pin=1 recoverWhile=recover_statement
        methods=[getPresentation]
    }

//private recover_statement ::= !(SEMI)

let_binding_body ::=
      EQUAL (expr | FUN)
    | (parameter)* ARROW (LBRACE (expr (SEMI expr)* | record_body) RBRACE | expr)

// https://caml.inria.fr/pub/docs/manual-ocaml/patterns.html#pattern
parameter ::=
      pattern_expr
    | SHORTCUT value_name
    | LPAREN pattern_expr (DOT type_expr)? RPAREN
    | LBRACE field (COMMA field)* RBRACE

pattern_expr ::=
      constant
    | value_name

// https://caml.inria.fr/pub/docs/manual-ocaml/names.html#field
field ::=
    (module_path DOT)? field_name

// ----------

record_body ::=
    record_field (COMMA record_field)*

record_field ::=
    field_name (COLON field_expr)?

field_expr ::=
      constant
    | value_path (DOT value_name)?
    | field_expr PLUS field_expr

// ----------
// CONSTANTS
//   https://caml.inria.fr/pub/docs/manual-ocaml/const.html#constant
// ----------

constant ::=
      INT
    | FLOAT
    | STRING
    | FALSE
    | TRUE
    | UNIT
    | LBRACKET RBRACKET

// ----------
// REFERRING NAMEDÂ OBJECTS
//   https://caml.inria.fr/pub/docs/manual-ocaml/names.html#sec90
// ----------

value_path ::=
      value_name
    | module_path DOT value_name

module_path ::=
    module_name (DOT module_name)*

// ----------
// NAMES
// https://caml.inria.fr/pub/docs/manual-ocaml/names.html
// ----------

value_name ::=
    LIDENT

tag_name ::=
    LIDENT | UIDENT

field_name ::=
    LIDENT

module_name ::=
    UIDENT

// ----------
// BUCKLESCRIPT
// ----------

bs_directive ::=
    LBRACKET BBS DOT (value_name|MODULE) constant? RBRACKET